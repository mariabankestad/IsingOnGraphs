import torch
import networkx as nx

import torch
from typing import List

from .explanation import Explanation

def aggregate_explanations(
        exp_list: List[Explanation], 
        reference_exp: Explanation = None,
        feature_aggregator = torch.max,
        node_aggregator = torch.max,
        edge_aggregator = torch.max,
        node_level: bool = True):
    '''
    Assumes all explanations are generated by a method that has

    Args:
        exp_list (List[Explanation]): List of explanations to aggregate
        reference_exp (Explanation, optional): 
    '''

    feature_imp = None
    node_imp = None
    edge_imp = None

    ref_exp = reference_exp if reference_exp is not None else exp_list[0]

    # Check for None's in the first explanation:
    if ref_exp.feature_imp is not None:
        feature_imp = feature_aggregator(torch.stack([exp.feature_imp for exp in exp_list]), dim = 0)[0]

    if ref_exp.node_imp is not None:
        node_imp = node_aggregator(torch.stack([exp.node_imp for exp in exp_list]), dim = 0)[0]

    if ref_exp.edge_imp is not None:
        edge_imp = edge_aggregator(torch.stack([exp.edge_imp for exp in exp_list]), dim = 0)[0]

    exp = Explanation(
        feature_imp = feature_imp,
        node_imp = node_imp,
        edge_imp = edge_imp,
        node_idx = ref_exp.node_idx
    )

    if node_level:
        exp.set_enclosing_subgraph(ref_exp.enc_subgraph)
    else:
        exp.set_whole_graph(ref_exp.graph)

    return exp

def to_networkx_conv(data, node_attrs=None, edge_attrs=None, to_undirected=False,
                remove_self_loops=False, get_map = False):
    r"""Converts a :class:`torch_geometric.data.Data` instance to a
    :obj:`networkx.Graph` if :attr:`to_undirected` is set to :obj:`True`, or
    a directed :obj:`networkx.DiGraph` otherwise.

    Args:
        data (torch_geometric.data.Data): The data object.
        node_attrs (iterable of str, optional): The node attributes to be
            copied. (default: :obj:`None`)
        edge_attrs (iterable of str, optional): The edge attributes to be
            copied. (default: :obj:`None`)
        to_undirected (bool, optional): If set to :obj:`True`, will return a
            a :obj:`networkx.Graph` instead of a :obj:`networkx.DiGraph`. The
            undirected graph will correspond to the upper triangle of the
            corresponding adjacency matrix. (default: :obj:`False`)
        remove_self_loops (bool, optional): If set to :obj:`True`, will not
            include self loops in the resulting graph. (default: :obj:`False`)
        get_map (bool, optional): If `True`, returns a tuple where the second
            element is a map from original node indices to new ones.
            (default: :obj:`False`)
    """
    if to_undirected:
        G = nx.Graph()
    else:
        G = nx.DiGraph()

    node_list = sorted(torch.unique(data.edge_index).tolist())
    map_norm = {node_list[i]:i for i in range(len(node_list))}
    #rev_map_norm = {v:k for k, v in map_norm.items()}
    G.add_nodes_from([map_norm[n] for n in node_list])

    values = {}
    for key, item in data:
        if torch.is_tensor(item):
            values[key] = item.squeeze().tolist()
        else:
            values[key] = item
        if isinstance(values[key], (list, tuple)) and len(values[key]) == 1:
            values[key] = item[0]

    for i, (u, v) in enumerate(data.edge_index.t().tolist()):
        u = map_norm[u]
        v = map_norm[v]

        if to_undirected and v > u:
            continue

        if remove_self_loops and u == v:
            continue

        G.add_edge(u, v)
        for key in edge_attrs if edge_attrs is not None else []:
            G[u][v][key] = values[key][i]

    for key in node_attrs if node_attrs is not None else []:
        for i, feat_dict in G.nodes(data=True):
            feat_dict.update({key: values[key][i]})

    if get_map:
        return G, map_norm
    else:
        return G
